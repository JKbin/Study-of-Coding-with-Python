# 각 자리 숫자(0~9)로 이루어진 문자열 S가 주어질 때, 왼쪽부터 오른쪽으로 하나씩 모든 숫자를
# 확인하며 숫자 사이에 'x' 혹은 '+' 연산자를 넣어 결과적으로
# 만들어질 수 있는 가장 큰 수를 구하라.
# 단, '+'보다 'x'를 먼저 계산하는 방식이 아닌,
# 모든 연산은 왼쪽부터 순서대로 이루어진다고 가정한다.

# ex) s = '02984'라는 문자열로 주어졌을 때
# 만들 수 있는 가장 큰 수는 ((((0+2)x9)x8)x4) = 576이다.
# 또한, 만들어질 수 있는 가장 큰 수는 항상 20억 이하의 정수가 되도록 s가 주어진다.


# 나의 풀이
# s[0] == 0일 때
# s = '02984' # 만약 s안에 0이 있으면 0 오른쪽 숫자와는 더하고 나머지는 다 곱하기

# s[0] != 0 이지만 나머지 인덱스 값에 0이 있을 때
# t = '20984' # 0이 있으니깐 왼쪽이랑은 더하고 나머지 다 곱하기

# s안에 0이 없을 때는 그냥 다 더하기
# u = '12345'


#############################################
# result = 0
# int(s[1])*int(s[2])*int(s[3])*int(s[4])


# if s[0] == 0:
#     result = int(s[1])
#     #*int(s[2])*int(s[3])*int(s[4])
# else:
#     pass
# print(result)


#############################################



# 풀이 
# 1. 대부분의 경우에는 '+' 보다 'x'를 하는게 낫다.
# 2. 하지만 두 수중에 하나라도 0 or 1이면, 곱하기 보다는 더하기를 수행하는게 효율적이다.
# 3. 따라서 연산을 수행할 때, 두 수중에 하나라도 1이하이면 더하기
# 4. 두 수가 모두 2이상인 경우에는 곱하면 된다.

s = '29084'
# 첫 번째 문자를 숫자로 변경하여 대입
result = int(s[0])
#print(result)

# 범위 s[1] ~ s[4] 
for i in range(1, len(s)):
    num = int(s[i])
    # 두 수 중에서 하나라도 '0' 혹은 '1'인 경우, 곱하기보다는 더하기 수행
    if num <= 1 or result <= 1:
        result += num
    else:
        result *= num

print(result)
        



    





